<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8" />
  <title>Display</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="app.css" />
</head>

<body>
  <h1>Display</h1>

  <div id="connectBox" class="mt20"></div>
  <div id="stateBox" class="mt20"></div>
  <div id="resultBox" class="mt20"></div>
  <div id="msgBox" class="mt20"></div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="config.js"></script>
  <script src="app.js"></script>

  <script>
    const connectBox = document.getElementById("connectBox");
    const stateBox = document.getElementById("stateBox");
    const resultBox = document.getElementById("resultBox");
    const msgBox = document.getElementById("msgBox");

    let unsubState = null;
    let unsubAgg = null;

    let sessionId = null;
    let joinCode = null;

    let currentRoundId = null;

    // Cache av siste data for å kunne rendre konsistent
    let lastState = null; // { status, mode, roundId, question }
    let lastAgg = null;   // { mode, n, counts }

    function setMsg(html) {
      msgBox.innerHTML = html || "";
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function safeJson(v) {
      try { return JSON.stringify(v, null, 2); } catch { return String(v); }
    }

    function parseQuery() {
      const p = new URLSearchParams(window.location.search);
      const s = p.get("sessionId");
      const j = p.get("joinCode");
      return {
        sessionId: s && s.trim() ? s.trim() : null,
        joinCode: j && j.trim() ? j.trim().toUpperCase().trim() : null
      };
    }

    function renderConnect() {
      connectBox.innerHTML = `
        <strong>Tilkobling</strong><br>
        sessionId: <span class="mono">${escapeHtml(sessionId || "-")}</span><br>
        joinCode: <span class="mono">${escapeHtml(joinCode || "-")}</span><br>
        Tips: Åpne display med <span class="mono">?joinCode=ABC123</span> eller <span class="mono">?sessionId=...</span>
      `;
    }

    function renderState(state) {
      if (!state) {
        stateBox.innerHTML = `<strong>State</strong><br>Ingen state/live funnet (mangler doc eller ingen tilgang).`;
        return;
      }

      stateBox.innerHTML = `
        <strong>State (live)</strong><br>
        status: <span class="mono">${escapeHtml(state.status ?? "-")}</span><br>
        mode: <span class="mono">${escapeHtml(state.mode ?? "-")}</span><br>
        roundId: <span class="mono">${escapeHtml(state.roundId ?? "-")}</span><br>
        question: <pre class="pre">${escapeHtml(safeJson(state.question))}</pre>
      `;
    }

    function clearResults() {
      resultBox.innerHTML = "";
    }

    function renderStandby() {
      stateBox.innerHTML = "";
      resultBox.innerHTML = `
        <strong>Venter på oppstart</strong><br>
        Denne skjermen er klar, men det er ingen aktiv kobling akkurat nå.<br><br>
        Åpne display med:<br>
        <span class="mono">display.html?joinCode=ABC123</span><br>
        eller<br>
        <span class="mono">display.html?sessionId=...</span>
      `;
    }

    function renderLoadingState() {
      resultBox.innerHTML = `<strong>Display</strong><br>Laster <span class="mono">state/live</span>…`;
    }

    function renderWaitingForRound() {
      resultBox.innerHTML = `<strong>Display</strong><br>State er lastet, men venter på aktiv <span class="mono">roundId</span>…`;
    }

    function renderWrongMode(mode) {
      resultBox.innerHTML = `
        <strong>Display</strong><br>
        Denne siden støtter kun <span class="mono">mode="multi"</span> i denne fasen.<br>
        Nåværende mode: <span class="mono">${escapeHtml(mode || "-")}</span>
      `;
    }

    function buildChoiceLabelMap(question) {
      const map = {};
      const q = question || {};
      const choices = Array.isArray(q.choices) ? q.choices : [];
      for (const c of choices) {
        if (!c) continue;
        const id = (c.id != null) ? String(c.id) : null;
        const label = (c.label != null) ? String(c.label) : (id || "");
        if (id) map[id] = label || id;
      }
      return map;
    }

    function renderMultiFromStateAndAgg(state, agg) {
      if (!state) {
        clearResults();
        return;
      }

      const status = state.status || null;
      const mode = state.mode || null;
      const roundId = state.roundId || null;

      if (mode && mode !== "multi") {
        renderWrongMode(mode);
        return;
      }

      if (!roundId) {
        renderWaitingForRound();
        return;
      }

      const counts = (agg && agg.counts && typeof agg.counts === "object") ? agg.counts : {};
      const n = (agg && typeof agg.n === "number") ? agg.n : 0;

      const labelMap = buildChoiceLabelMap(state.question);

      const qChoices = (state.question && Array.isArray(state.question.choices)) ? state.question.choices : [];
      const haveChoiceList = qChoices.length >= 2;

      let rows = "";

      if (haveChoiceList) {
        rows = qChoices.map((c, idx) => {
          const id = (c && c.id != null) ? String(c.id) : ("choice_" + (idx + 1));
          const label = (c && (c.label || c.text)) ? String(c.label || c.text) : (labelMap[id] || id);
          const v = (typeof counts[id] === "number") ? counts[id] : 0;
          return `<tr><td>${escapeHtml(label)}</td><td class="mono">${v}</td></tr>`;
        }).join("");
      } else {
        const entries = Object.entries(counts);
        entries.sort((a, b) => (b[1] || 0) - (a[1] || 0));
        if (!entries.length) {
          rows = `<tr><td>(ingen)</td><td class="mono">0</td></tr>`;
        } else {
          rows = entries.map(([id, v]) => {
            const label = labelMap[String(id)] || String(id);
            return `<tr><td>${escapeHtml(label)}</td><td class="mono">${typeof v === "number" ? v : 0}</td></tr>`;
          }).join("");
        }
      }

      const statusLine = (status === "collect")
        ? `Innsamling pågår (<span class="mono">collect</span>)`
        : (status === "results")
          ? `Resultater vises (<span class="mono">results</span>)`
          : `Status: <span class="mono">${escapeHtml(status || "-")}</span>`;

      resultBox.innerHTML = `
        <strong>Resultat (MULTI)</strong><br>
        ${statusLine}<br>
        roundId: <span class="mono">${escapeHtml(roundId)}</span><br>
        n: <span class="mono">${n}</span><br>

        <table class="mt20">
          <thead><tr><th>Valg</th><th>Antall</th></tr></thead>
          <tbody>${rows}</tbody>
        </table>
      `;
    }

    function render() {
      renderMultiFromStateAndAgg(lastState, lastAgg);
    }

    function detachAgg() {
      if (unsubAgg) unsubAgg();
      unsubAgg = null;
      lastAgg = null;
    }

    function attachAgg(sessionId, roundId) {
      detachAgg();

      unsubAgg = App.listenAgg(
        sessionId,
        roundId,
        (agg) => {
          lastAgg = agg;
          render();
        },
        (err) => {
          const m = err && err.message ? err.message : String(err);
          setMsg("<strong>Kunne ikke lese agg/live:</strong><br><span class=\"mono\">" + escapeHtml(m) + "</span>");
        }
      );
    }

    function attachState(sessionId) {
      if (unsubState) unsubState();

      unsubState = App.listenLiveState(
        sessionId,
        (state) => {
          lastState = state;
          renderState(state);
          setMsg("");

          if (!state) {
            currentRoundId = null;
            detachAgg();
            clearResults();
            return;
          }

          const mode = state.mode || null;
          const roundId = state.roundId || null;

          if (mode && mode !== "multi") {
            currentRoundId = roundId || null;
            detachAgg();
            lastAgg = null;
            render();
            return;
          }

          if (!roundId) {
            currentRoundId = null;
            detachAgg();
            render();
            return;
          }

          if (roundId !== currentRoundId) {
            currentRoundId = roundId;
            attachAgg(sessionId, roundId);
          }

          render();
        },
        (err) => {
          const m = err && err.message ? err.message : String(err);
          setMsg("<strong>Kunne ikke lese state/live:</strong><br><span class=\"mono\">" + escapeHtml(m) + "</span>");
        }
      );
    }

    async function boot() {
      const q = parseQuery();
      joinCode = q.joinCode;
      sessionId = q.sessionId;

      renderConnect();

      // Ingen parametre -> standby (ikke prøv deltaker-cache her)
      if (!sessionId && !joinCode) {
        setMsg("");
        renderStandby();
        return;
      }

      // Hvis vi bare har joinCode: resolve -> sessionId
      if (!sessionId && joinCode) {
        try {
          const res = await App.resolveJoinCode(joinCode);
          sessionId = res.sessionId;
          renderConnect();
        } catch (e) {
          const m = e && e.message ? e.message : String(e);
          setMsg(
            "<strong>Koden er ikke aktiv.</strong><br>" +
            "Den kan være utløpt eller feil.<br><br>" +
            "joinCode: <span class=\"mono\">" + escapeHtml(joinCode) + "</span><br>" +
            "<span class=\"mono\">" + escapeHtml(m) + "</span>"
          );
          renderStandby();
          return;
        }
      }

      if (!sessionId) {
        setMsg("Mangler sessionId. Åpne display med <span class=\"mono\">?joinCode=ABC123</span> eller <span class=\"mono\">?sessionId=...</span>.");
        renderStandby();
        return;
      }

      renderLoadingState();
      attachState(sessionId);
    }

    boot();
  </script>
</body>
</html>
