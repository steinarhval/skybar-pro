<!DOCTYPE html>
<html lang="no">
<head>
  <meta charset="UTF-8" />
  <title>Innhenting</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="app.css" />
</head>

<body>
  <h1>Innhenting</h1>

  <div id="infoBox" class="mt20"></div>
  <div id="stateBox" class="mt20"></div>
  <div id="voteBox" class="mt20"></div>
  <div id="msgBox" class="mt20"></div>

  <div class="mt20">
    <button id="backBtn">Tilbake</button>
  </div>

  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
  <script src="config.js"></script>
  <script src="app.js"></script>

  <script>
    const infoBox = document.getElementById("infoBox");
    const stateBox = document.getElementById("stateBox");
    const voteBox = document.getElementById("voteBox");
    const msgBox = document.getElementById("msgBox");
    const backBtn = document.getElementById("backBtn");

    let unsubState = null;
    let unsubLock = null;

    let currentSessionId = null;
    let currentJoinCode = null;

    let currentRoundId = null;
    let currentMode = null;
    let currentQuestion = null;

    // lockState: "none" | "unknown" | "unlocked" | "locked"
    let lockState = "none";

    // boot guards / reconnect guards
    let bootDone = false;
    let reconnectTimer = null;
    let lastReconnectAt = 0;

    function setMsg(html) {
      msgBox.innerHTML = html || "";
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;");
    }

    function renderInfo() {
      infoBox.innerHTML = `
        <strong>Tilkobling</strong><br>
        sessionId: <span class="mono">${escapeHtml(currentSessionId || "(mangler)")}</span><br>
        joinCode: <span class="mono">${escapeHtml(currentJoinCode || "(mangler)")}</span><br>
        clientId: <span class="mono">${escapeHtml(App.getClientId())}</span>
      `;
    }

    function safeJson(v) {
      try { return JSON.stringify(v, null, 2); } catch { return String(v); }
    }

    function renderState(state) {
      if (!state) {
        stateBox.innerHTML = `<strong>State</strong><br>Ingen state/live funnet (mangler doc eller ingen tilgang).`;
        return;
      }

      stateBox.innerHTML = `
        <strong>State (live)</strong><br>
        status: <span class="mono">${escapeHtml(state.status ?? "-")}</span><br>
        mode: <span class="mono">${escapeHtml(state.mode ?? "-")}</span><br>
        roundId: <span class="mono">${escapeHtml(state.roundId ?? "-")}</span><br>
        question: <pre class="pre">${escapeHtml(safeJson(state.question))}</pre>
      `;
    }

    function setVoteUIWaiting() {
      voteBox.innerHTML = `<strong>Stemme</strong><br>Venter på aktiv roundId og mode/spørsmål.`;
    }

    function setVoteUICheckingLock() {
      voteBox.innerHTML = `<strong>Stemme</strong><br><span class="mono">Sjekker om du allerede har stemt…</span>`;
    }

    function setVoteUILockedAlready() {
      voteBox.innerHTML = `<strong>Stemme</strong><br><span class="mono">Du har allerede stemt i denne runden (låst).</span>`;
    }

    function renderMulti(choices) {
      const buttons = choices.map((c, idx) => {
        const label = (c && (c.label || c.text)) ? (c.label || c.text) : ("Valg " + (idx + 1));
        const value = (c && c.id) ? c.id : label;
        return `<button class="btn" data-v="${encodeURIComponent(String(value))}">${escapeHtml(label)}</button>`;
      }).join("");

      voteBox.innerHTML = `
        <strong>Stemme (MULTI)</strong>
        <div class="btnRow mt20" id="choiceRow">${buttons}</div>
      `;

      document.getElementById("choiceRow").addEventListener("click", (ev) => {
        const btn = ev.target.closest("button[data-v]");
        if (!btn) return;
        const v = decodeURIComponent(btn.getAttribute("data-v"));
        submitVote("multi", v);
      });
    }

    function renderLikert() {
      voteBox.innerHTML = `
        <strong>Stemme (LIKERT)</strong><br>
        <div class="mt20">
          <input id="likertInput" class="input" type="number" inputmode="numeric" placeholder="0-10" />
          <button id="likertSend" class="btn">Send</button>
        </div>
      `;

      document.getElementById("likertSend").addEventListener("click", () => {
        const raw = document.getElementById("likertInput").value;
        const n = Number(raw);
        if (!Number.isFinite(n)) {
          setMsg('<span class="mono">Skriv inn et tall.</span>');
          return;
        }
        submitVote("likert", n);
      });
    }

    function renderOpen() {
      voteBox.innerHTML = `
        <strong>Stemme (OPEN)</strong><br>
        <div class="mt20">
          <textarea id="openInput" class="inputArea" rows="4" placeholder="Skriv svaret ditt..."></textarea>
          <div class="mt20">
            <button id="openSend" class="btn">Send</button>
          </div>
        </div>
      `;

      document.getElementById("openSend").addEventListener("click", () => {
        const t = (document.getElementById("openInput").value || "").trim();
        if (!t) {
          setMsg('<span class="mono">Skriv noe før du sender.</span>');
          return;
        }
        submitVote("open", t);
      });
    }

    function renderWordcloud() {
      voteBox.innerHTML = `
        <strong>Stemme (WORDCLOUD)</strong><br>
        <div class="mt20">
          <input id="wcInput" class="inputWide" type="text" placeholder="Ett ord eller kort frase" />
          <button id="wcSend" class="btn">Send</button>
        </div>
      `;

      document.getElementById("wcSend").addEventListener("click", () => {
        const t = (document.getElementById("wcInput").value || "").trim();
        if (!t) {
          setMsg('<span class="mono">Skriv noe før du sender.</span>');
          return;
        }
        submitVote("wordcloud", t);
      });
    }

    function renderVoteUI() {
      if (!currentRoundId || !currentMode) {
        lockState = currentRoundId ? lockState : "none";
        setVoteUIWaiting();
        return;
      }

      if (lockState === "unknown") {
        setVoteUICheckingLock();
        return;
      }

      if (lockState === "locked") {
        setVoteUILockedAlready();
        return;
      }

      if (currentMode === "multi") {
        const q = currentQuestion || {};
        const choices = Array.isArray(q.choices) ? q.choices : null;
        if (!choices || choices.length < 2) {
          setVoteUIWaiting();
          return;
        }
        renderMulti(choices);
        return;
      }

      if (currentMode === "likert") { renderLikert(); return; }
      if (currentMode === "open") { renderOpen(); return; }
      if (currentMode === "wordcloud") { renderWordcloud(); return; }

      setVoteUIWaiting();
    }

    async function submitVote(mode, value) {
      if (!currentSessionId || !currentRoundId) return;

      if (lockState !== "unlocked") {
        setMsg("");
        setVoteUILockedAlready();
        return;
      }

      setMsg("");
      try {
        const res = await App.submitVoteOnce(currentSessionId, currentRoundId, mode, value);
        lockState = "locked";
        renderVoteUI();

        if (!(res && res.already)) {
          setMsg('<span class="mono">Takk! Stemmen er sendt.</span>');
        }
      } catch (e) {
        const msg = e && e.message ? e.message : String(e);
        setMsg('<strong>Kunne ikke sende stemme:</strong><br><span class="mono">' + escapeHtml(msg) + "</span>");
      }
    }

    function detachAllListeners() {
      if (unsubState) unsubState();
      if (unsubLock) unsubLock();
      unsubState = null;
      unsubLock = null;
    }

    function attachLock(sessionId, roundId) {
      if (unsubLock) unsubLock();

      lockState = "unknown";
      setMsg("");
      renderVoteUI();

      const clientId = App.getClientId();
      unsubLock = App.listenVoteLock(
        sessionId,
        roundId,
        clientId,
        (res) => {
          lockState = (res && res.exists) ? "locked" : "unlocked";
          renderVoteUI();
        },
        (err) => {
          const msg = err && err.message ? err.message : String(err);
          setMsg('<strong>Kunne ikke lese vote-lock:</strong><br><span class="mono">' + escapeHtml(msg) + "</span>");
          // behold "unknown" så UI sier sannheten
          lockState = "unknown";
          renderVoteUI();
        }
      );
    }

    function attachState(sessionId) {
      if (unsubState) unsubState();

      unsubState = App.listenLiveState(
        sessionId,
        (state) => {
          renderState(state);

          currentMode = state && state.mode ? state.mode : null;
          currentQuestion = state && state.question ? state.question : null;

          const newRoundId = state && state.roundId ? state.roundId : null;

          if (newRoundId !== currentRoundId) {
            currentRoundId = newRoundId;

            if (currentRoundId) attachLock(currentSessionId, currentRoundId);
            else {
              if (unsubLock) unsubLock();
              unsubLock = null;
              lockState = "none";
              setMsg("");
            }
          }

          renderVoteUI();
        },
        (err) => {
          const msg = err && err.message ? err.message : String(err);
          setMsg('<strong>Kunne ikke lese state/live:</strong><br><span class="mono">' + escapeHtml(msg) + "</span>");
        }
      );
    }

    // --- Wake-up reconnect (uten pageshow-loop) ---
    async function enableNetworkBestEffort() {
      try {
        if (App && App.db && typeof App.db.enableNetwork === "function") {
          await App.db.enableNetwork();
        }
      } catch (_) {}
    }

    function scheduleReconnect(reason) {
      if (!bootDone) return;
      if (!currentSessionId) return;
      if (document.hidden) return;

      if (reconnectTimer) clearTimeout(reconnectTimer);
      reconnectTimer = setTimeout(async () => {
        const now = Date.now();
        if (now - lastReconnectAt < 2000) return; // rate limit
        lastReconnectAt = now;

        await enableNetworkBestEffort();

        // Re-attach state (og lock hvis vi allerede har roundId)
        if (unsubState) { unsubState(); unsubState = null; }
        attachState(currentSessionId);

        if (currentRoundId) {
          attachLock(currentSessionId, currentRoundId);
        }
      }, 300);
    }

    document.addEventListener("visibilitychange", () => {
      if (!document.hidden) scheduleReconnect("visibility");
    });
    window.addEventListener("focus", () => scheduleReconnect("focus"));
    window.addEventListener("online", () => scheduleReconnect("online"));

    // NB: vi bruker IKKE pageshow her – den lager trøbbel på noen mobiler.
    // Hvis du absolutt trenger BFCache-håndtering senere, gjør vi det med persisted==true, ikke alltid.

    function parseQueryJoinCode() {
      const p = new URLSearchParams(window.location.search);
      const jc = (p.get("joinCode") || "").trim().toUpperCase();
      if (/^[A-Z0-9]{6}$/.test(jc)) return jc;
      return null;
    }

    async function boot() {
      try {
        const urlJoin = parseQueryJoinCode();

        if (urlJoin) {
          const res = await App.resolveJoinCode(urlJoin);
          currentSessionId = res.sessionId;
          currentJoinCode = urlJoin;

          // viktig: overskriv localStorage så vi ikke “henger igjen” i gammel kode
          App.setParticipantSession(currentSessionId, currentJoinCode);
        } else {
          const p = App.getParticipantSession();
          if (p && p.sessionId && p.joinCode) {
            currentSessionId = p.sessionId;
            currentJoinCode = p.joinCode;
          }
        }

        if (!currentSessionId || !currentJoinCode) {
          renderInfo();
          setMsg('Mangler join-informasjon. Gå til <span class="mono">join.html</span> og skriv inn kode.');
          setVoteUIWaiting();
          bootDone = true;
          return;
        }

        renderInfo();
        attachState(currentSessionId);
        setVoteUIWaiting();
        setMsg("");

        bootDone = true;
      } catch (e) {
        const msg = e && e.message ? e.message : String(e);
        renderInfo();
        setMsg('<strong>Oppstart feilet:</strong><br><span class="mono">' + escapeHtml(msg) + "</span>");
        setVoteUIWaiting();
        bootDone = true;
      }
    }

    backBtn.addEventListener("click", () => {
      window.location.href = "join.html";
    });

    boot();
  </script>
</body>
</html>
